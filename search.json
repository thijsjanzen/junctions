[{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"overview-of-the-junctions-package","dir":"Articles","previous_headings":"","what":"Overview of the junctions package","title":"Overview_of_the_junctions_package","text":"junctions package since ’s creation 2018 updated range extended functionality, spawning many associated functions. vignette aimed providing clear overview several functions available, displaying can potentially use functions.","code":""},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"simulation-functions","dir":"Articles","previous_headings":"Overview of the junctions package","what":"Simulation functions","title":"Overview_of_the_junctions_package","text":"many functions rely input data, first explore functions simulate data. functions simulate accumulation junctions Wright-Fisher model, random mating, fixed population size, non-overlapping generations recombination modeled mean number crossovers drawn Poisson distribution size Morgan chromosome mean distribution. location crossovers drawn uniform distribution across chromosome. simulations, one pair chromosomes per individual simulated.","code":""},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"phased-and-unphased-simulations","dir":"Articles","previous_headings":"Overview of the junctions package > Simulation functions","what":"Phased and unphased simulations","title":"Overview_of_the_junctions_package","text":"recent additions package, user can simulate process junction accumulation, detection ancestry given set markers. simulations designed reflect type data one might get upon sequencing individuals. Simulations aimed matching analytical results can found later . data returned long data format, user can, required, superimpose phasing inaccuracy reduced marker coverage.","code":"simulated_pop <- sim_phased_unphased(pop_size = 1000,                                      freq_ancestor_1 = 0.5,                                      total_runtime = 100,                                      size_in_morgan = 1,                                      markers = sort(runif(n = 1000, 0, 1)),                                      time_points = seq(0, 100, by = 10))"},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"mathematical-simulations","dir":"Articles","previous_headings":"Overview of the junctions package > Simulation functions","what":"Mathematical simulations","title":"Overview_of_the_junctions_package","text":"Janzen et al. 2018, two separate scenario’s explored: either using finite infinite chromosome, finite infinite referring number junctions possibly spaced chromosome. retain functionality suggested paper, also retain code used paper, functionality available functions . functions aimed performing stochastic simulations accumulation junctions, placing spacing markers affects detection junctions. , simulations return population average number accumulated junctions, number detected junctions (given markers, infinite chromosome), actual local ancestry.","code":"junctions_fin_chrom <- sim_fin_chrom(pop_size = 1000,                                      freq_ancestor_1 = 0.5,                                      total_runtime = 200,                                      morgan = 1,                                      R = 100) # the number of crossover sites  junctions_inf_chrom <- sim_inf_chrom(pop_size = 1000,                                      freq_ancestor_1 = 0.5,                                      total_runtime = 200,                                      morgan = 1,                                      markers = 100)  plot(junctions_inf_chrom$avgJunctions,      type = \"l\", lwd = 2,      col = \"darkgreen\",      xlab = \"Time since admixture\",      ylab = \"Number of junctions\") lines(junctions_fin_chrom$avgJunctions, col = \"blue\", lwd = 2) lines(junctions_inf_chrom$detectedJunctions, col = \"lightgreen\", lwd = 2) legend(\"topleft\", legend = c(\"Finite chromosome\", \"Infinite chromosome\",                              \"Infinite chromosome detected\"),        col = c(\"blue\", \"darkgreen\", \"lightgreen\"), lty = 1, lwd = 2)"},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"backcrossing","dir":"Articles","previous_headings":"Overview of the junctions package > Simulation functions","what":"Backcrossing","title":"Overview_of_the_junctions_package","text":"Lastly, one additional function available, instead random mating, individuals cross back one parents, used Lavretsky et al. 2019. function also focuses mainly average number junctions distribution local ancestry","code":"backcross_result <- sim_backcrossing(population_size = 1000,                                      freq_ancestor_1 = 0.5,                                      total_runtime = 20,                                      size_in_morgan = 1,                                      number_of_markers = 100)  plot(backcross_result$average_junctions,      type = \"l\", lwd = 2,      col = \"darkgreen\",      xlab = \"Time since admixture\",      ylab = \"Number of junctions\")"},{"path":[]},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"junction-based-methods","dir":"Articles","previous_headings":"Overview of the junctions package > Inferring the time since admixture","what":"Junction based methods","title":"Overview_of_the_junctions_package","text":"Across Janzen et al. 2018 Janzen & Miró Pina 2022, several equations proposed infer time since admixture, depending data available. Firstly, following equation 14 Janzen et al. 2018, one can calculate time since admixture based number junctions detected one chromosome, given number regularly spaced markers: reality, markers rarely regularly spaced practical applications equation 14 Janzen et al. 2018 limited. Therefore, Janzen & Miró Pina propose exact method (Equation 3) calculating expected number junctions single chromosome, given distribution markers across chromosome.","code":"estimate_time(J = 10, N = 1000, R = 1000, H_0 = 0.5, C = 1) ## [1] 20.2909 estimate_time_one_chrom(J = 10, N = 1000, H_0 = 0.5,                         marker_distribution = sort(runif(n = 1000, 0, 1))) ## [1] 20.5195"},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"local-ancestry-based-methods","dir":"Articles","previous_headings":"Overview of the junctions package > Inferring the time since admixture","what":"Local ancestry based methods","title":"Overview_of_the_junctions_package","text":"Mathematically, total number junctions tractable, however discards ancestry data collected respective markers. Janzen & Miró Pina therefore provide alternative likelihood based method, also allows joint inference time since admixture across data resulting multiple chromosomes individual. assumed individual interest haploid, since data single chromosome available. example , make use previously simulated data pretend different chromosomes resulting different individuals , fact, sampled individual. course completely mathematically incorrect, used demonstrate use functions. function requires input called ‘ancestry_matrix’, matrix three columns: 1) chromosome indicator, 2) position respective chromosome Morgan 3) local ancestry. function returns maximum likelihood estimate time, associated likelihood. instead, diploid ancestry data, can make use function . function can calculate ancestry assuming either data phased, unphased. , take data, add ‘fake’ individual information. , function requires input matrix following five columns: 1) individual, 2) chromosome, 3) location along respective chromosome Morgan, 4) ancestry chromosome 1, 5) ancestry chromosome 2. Please note case unphased data, matter ancestry split across two chromosomes. Note although possession phasing information (using simulation output), can ‘fake’ data unphased, case analysis take account phasing information. can specify analysis type, focuses likelihoods grouped. default, likelihood calculated jointly chromosomes within individual. Thus, multiple individuals provided, multiple time estimates returned. Instead, one can also specify group data chromosome, jointly optimizing across individuals (recommended). Lastly, one can specify split data per individual chromosome provide separate estimates chromosome found individual. thus find specific case, time estimate using unphased data slightly accurate phased case, although close.","code":"ancestry_data <- subset(simulated_pop, simulated_pop$time == 100) ancestry_matrix <- dplyr::select(ancestry_data, c(individual,                                                   location, anc_chrom_1)) estimate_time_haploid(ancestry_matrix = ancestry_matrix,                       N = 1000,                       freq_ancestor_1 = 0.5) ## $time ## [1] 104.862 ##  ## $loglikelihood ## [1] -1673.448 ancestry_matrix <- dplyr::select(ancestry_data, c(individual,                                                   location,                                                   anc_chrom_1, anc_chrom_2)) ancestry_matrix <- cbind(rep(1, length(ancestry_matrix$individual)),                          ancestry_matrix)  t_phased <- estimate_time_diploid(ancestry_information = ancestry_matrix,                                   analysis_type = \"individuals\",                                   phased = TRUE,                                   pop_size = 1000,                                   freq_ancestor_1 = 0.5)  t_unphased <- estimate_time_diploid(ancestry_information = ancestry_matrix,                                     analysis_type = \"individuals\",                                     phased = FALSE,                                     pop_size = 1000,                                     freq_ancestor_1 = 0.5)  t_phased ## # A tibble: 1 × 3 ##   individual  time loglikelihood ##        <dbl> <dbl>         <dbl> ## 1          1  104.        -3345. t_unphased ## # A tibble: 1 × 3 ##   individual  time loglikelihood ##        <dbl> <dbl>         <dbl> ## 1          1  102.        -2924."},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"likelihood-functions","dir":"Articles","previous_headings":"Overview of the junctions package","what":"Likelihood functions","title":"Overview_of_the_junctions_package","text":"like investigate likelihood profile around maximum, instance assess accurate estimate , can respective likelihood functions.  Alternatively, can calculate haploid log likelihood, e.g. likelihood observing ancestry one chromosome:","code":"ancestry_matrix <- dplyr::select(ancestry_data, c(individual, location,                                                   anc_chrom_1, anc_chrom_2))  time_points <- 80:120 ll_phased <- log_likelihood_diploid(ancestry_matrix,                                     pop_size = 1000,                                     freq_ancestor_1 = 0.5,                                     t = time_points,                                     phased = TRUE) ll_unphased <- log_likelihood_diploid(ancestry_matrix,                                       pop_size = 1000,                                       freq_ancestor_1 = 0.5,                                       t = time_points,                                       phased = FALSE)  to_plot <- tibble::tibble(time_points, ll_phased, ll_unphased) to_plot %>%   tidyr::gather(key = \"phasing\", value = \"loglikelihood\", -time_points) %>%   ggplot2::ggplot(       ggplot2::aes(x = time_points, y = loglikelihood, col = phasing)) +   ggplot2::geom_line() ancestry_matrix <- dplyr::select(ancestry_data, c(individual, location,                                                   anc_chrom_1))  ll_haploid <- log_likelihood_haploid(ancestry_matrix,                                      N = 1000,                                      freq_ancestor_1 = 0.5,                                      t = time_points) plot(ll_haploid ~ time_points, type = \"l\",      xlab = \"Time since admixture\",      ylab = \"Loglikelihood\")"},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"expected-number-of-junctions","dir":"Articles","previous_headings":"Overview of the junctions package","what":"Expected number of junctions","title":"Overview_of_the_junctions_package","text":"Mathematically, one can calculate expected number junctions. first equation covered covers derivations obtained Janzen et al. 2018: equation however, assume markers equally spaced, , distance consecutive marker pair equal. rarely case empirical data, better version provided function : Similarly, can calculate probability observing junction two markers, given amount recombination (Morgan) two markers: Lastly, included function calculates expected number junctions number generations, backcrossing mating scheme.","code":"number_of_junctions(N = 100, R = 100, H_0 = 0.5, C = 1, t = 1000) ## [1] 33.33332 number_of_junctions_markers(N = 100, H_0 = 0.5, t = 1000,                             marker_distribution = sort(runif(100, 0, 1))) ## [1] 27.16975 number_of_junctions_di(N = 100, H_0 = 0.5, t = 1000, di = 1e-5) ## [1] 0.0009914297 number_of_junctions_backcross(H_0 = 0.5, C = 1, t = 10) ## [1] 0.009765625"},{"path":"https://thijsjanzen.github.io/junctions/articles/Overview_of_the_junctions_package.html","id":"mathematical-expressions","dir":"Articles","previous_headings":"Overview of the junctions package","what":"Mathematical expressions","title":"Overview_of_the_junctions_package","text":"Following Janzen et al. 2018, number equations might useful. Firstly, equation calculate upper limit junctions can packed chromosome, given number (regularly spaced) markers: time spent population reached upper limit remains “invisible” inference purposes, thus can useful calculate upper limit age inference, coined ‘Maximum Accurate Time’, following equation 15 Janzen et al. 2018: Similarly, can estimate error induced time inference, error given amount time difference induced infer one junction less (), following Equations 3 & 4 Supplementary information Janzen et al. 2018. concludes runthrough available functions junctions package. Feel free contact feel anything missing, create issue run problem.","code":"calc_k(N = 1000, R = 1000, H_0 = 0.5, C = 1) ## [1] 333.3333 calculate_mat(N = 1000, R = 1000, H_0 = 0.5, C = 1) ## [1] 3869.857 time_error(t = 30, N = 1000, R = 1000, H_0 = 0.5, C = 1) ## [1] 0.0697948"},{"path":"https://thijsjanzen.github.io/junctions/articles/junctions_vignette.html","id":"junctions-vignette","dir":"Articles","previous_headings":"","what":"Junctions vignette","title":"Junctions Vignette","text":"vignette take different functions provided R package ‘junctions’, show functions interrelate . package junctions bundled functions simulation code study ancestry blocks hybridization decay due recombination. assume populations constant population size, random mating, uniform recombination rate across chromosome (see Supplementary material paper scenario’s relax assumptions). Furthermore, assume secondary introgression takes place, ignore effect selection (see Discussion section main paper full discussion scenario’s covered model).","code":""},{"path":"https://thijsjanzen.github.io/junctions/articles/junctions_vignette.html","id":"an-infinite-chromosome-in-a-finite-population","dir":"Articles","previous_headings":"Junctions vignette","what":"An infinite chromosome in a finite population","title":"Junctions Vignette","text":"simulate process junction accumulation time, can make use function function number arguments: population size, initial heterozygosity, total runtime simulation generations, size chromosome morgan, flag indicating number markers used (-1 markers interest) random seed. function returns object containing “avgJunctions”, vector average number junctions t = [0:total_runtime]. demonstrate use, choose simple parameters: Given stochastic junction accumulation, observe number junctions, although time increasing, performs relatively stochastic walk. compare accumulation junctions mathematical predictions, need average number replicates. , can compare obtained mean estimates predicted number junctions following mathematical prediction. using function ‘number_of_junctions’ (Equation 11 Janzen et al. 2017) see simulations exactly match prediction, can improved increasing number replicates (haven’t done , dramatically increase runtime).","code":"sim_inf_chrom(pop_size,               initial_heterozygosity,               total_runtime,               morgan,               markers,               seed) pop_size <- 100 # population size h_0 <- 0.5 # initial heterozygosity maximum_time <- 1000 # run time c <- 1 # number of recombinations per meiosis  # we first ignore the effect of imposing randomly distributed markers number_of_markers <- -1  v <- sim_inf_chrom(pop_size = pop_size,                    freq_ancestor_1 = h_0,                    total_runtime = maximum_time,                    morgan = c,                    markers = number_of_markers,                    seed = 42)  plot(v$avgJunctions,      type = \"l\",      xlab = \"Generations\",      ylab = \"Number of Junctions\",      main = \"Example Infinite Chromosome\") number_replicates <- 10 v <- c() for (r in 1:number_replicates) {   v2 <- sim_inf_chrom(pop_size = pop_size,                       freq_ancestor_1 = h_0,                       total_runtime = maximum_time,                       morgan = c,                       markers = number_of_markers,                       seed = r)   v <- rbind(v, as.numeric(v2$avgJunctions)) } v <- colMeans(v) #mean across replicates clarity <- seq(1,                maximum_time,                length.out = 50) # we plot not all points, for clarity plot(v[clarity] ~ clarity, lwd = 2,      xlab = \"Generations\",      ylab = \"Number of Junctions\",      main = \"Average behaviour Infinite chromosome\", pch = 16)  t <- 0:maximum_time predicted <- number_of_junctions(N = pop_size, H_0 = h_0, C = c, t = t) lines(predicted ~ t, col = \"blue\")"},{"path":"https://thijsjanzen.github.io/junctions/articles/junctions_vignette.html","id":"including-random-markers","dir":"Articles","previous_headings":"Junctions vignette > An infinite chromosome in a finite population","what":"Including Random Markers","title":"Junctions Vignette","text":"far, kept markers flag -1, forces code ignore effect randomly distributed markers. Setting flag positive number R makes simulation impose R randomly distributed markers upon chromosome evaluate number junctions based genomic content locations markers. markers positive number, function “sim_inf_chrom” returns vector “avgJunctions”, also vector “detectedJunctions”, contains number junctions detected, given provided number markers.  can repeat analysis number replicates acquire mean dynamics: can now plot true number junctions, number detected, number predicted mathematical analysis. Furthermore, can substitute K maximum number junctions end simulation, use empirical value K predict number junctions instead.","code":"pop_size <- 100 # population size h_0 <- 0.5 # initial heterozygosity maximum_time <- 1000 # run time c <- 1 # number of recombinations per meiosis number_of_markers <- 1000 # 1000 markers  #single example run v <- sim_inf_chrom(pop_size = pop_size,                    freq_ancestor_1 = h_0,                    total_runtime = maximum_time,                    morgan = c,                    markers = number_of_markers,                    seed = 42) plot(v$avgJunctions,      type = \"l\",      xlab = \"Generations\",      ylab = \"Number of Junctions\",      main = \"Example Infinite Chromosome\")  lines(v$detectedJunctions, col = \"blue\") legend(\"bottomright\",        c(\"Real number\", \"Number detected\"),        lty = 1,        col = c(\"black\", \"blue\")) mean_junctions <- c() detected_junctions <- c() for (r in 1:number_replicates) {   v2 <- sim_inf_chrom(pop_size = pop_size,                       freq_ancestor_1 =  h_0,                       total_runtime = maximum_time,                       morgan = c,                       markers = number_of_markers,                       seed = r + 42)   mean_junctions <- rbind(mean_junctions,                           as.numeric(v2$avgJunctions))   detected_junctions <- rbind(detected_junctions,                               as.numeric(v2$detectedJunctions)) } mean_junctions <- colMeans(mean_junctions) detected_junctions <- colMeans(detected_junctions) #we plot not all points, for clarity clarity <- seq(1, maximum_time, length.out = 50) plot(mean_junctions[clarity] ~ clarity,      xlab = \"Generations\",      ylab = \"Number of Junctions\",      main = \"Average behaviour Infinite chromosome\",      pch = 16)  points(detected_junctions[clarity] ~ clarity,        pch = 17,        col = \"blue\")  t <- 0:maximum_time predicted <- number_of_junctions(N = pop_size,                                  H_0 = h_0,                                  C = c,                                  t = t) lines(predicted ~ t, lwd = 2)  # now substitute K with the observed maximum detected. k <- tail(detected_junctions, 1) pred <- k - k * (1 - h_0 * c / k) ^ t lines(pred ~ t, col = \"blue\", lwd = 2)  legend(\"bottomright\",        c(\"Real number\", \"Detected\",          \"Predicted Real\", \"Predicted Detected\"),        pch = c(16, 17, NA, NA),        lty = c(NA, NA, 1, 1),        col = c(\"black\", \"blue\",                \"black\", \"blue\"),        lwd = 2)"},{"path":"https://thijsjanzen.github.io/junctions/articles/junctions_vignette.html","id":"a-finite-chromosome-in-a-finite-population","dir":"Articles","previous_headings":"Junctions vignette","what":"A Finite chromosome in a finite population","title":"Junctions Vignette","text":"simulate finite chromosome regularly spaced markers, use different, efficient, C code ‘hood’. user make use code, function ‘sim_fin_chrom’ can used: Arguments function ‘sim_fin_chrom’ identical ‘sim_inf_chrom’, excluding markers flag, including parameter R, indicating number genetic markers used. Usage identical , can obtain single run follows:  facilitate comparison empirical data, might want take mean number replicates: , using function ‘number_of_junctions’, time providing argument R, can compare findings mathematical predictions :","code":"sim_fin_chrom(pop_size,               initial_heterozygosity,               total_runtime,               morgan,               seed,               R) r <- 100 # chromosome size n <- 100 # population size freq_ancestor_1 <- 0.5 # frequency of ancestor 1 at t = 0 c <- 1 # number of recombinations per meiosis maximum_time <- 1000  #single example run v <- sim_fin_chrom(pop_size = n,                    freq_ancestor_1 = freq_ancestor_1,                    total_runtime = maximum_time,                    morgan = c,                    seed = 42,                    R = r) plot(v$avgJunctions, type = \"l\",      xlab = \"Generations\",      ylab = \"Number of Junctions\",      main = \"Example Finite Chromosome\") v <- c() for (repl in 1:number_replicates) {   v2 <- sim_fin_chrom(pop_size = n,                       freq_ancestor_1 = h_0,                       total_runtime = maximum_time,                       morgan = c,                       seed = repl,                       R = r)   v <- rbind(v, as.numeric(v2$avgJunctions)) } v <- colMeans(v) clarity <- seq(1, 1000, length.out = 50) #we plot not all points, for clarity plot(v[clarity] ~ clarity, lwd = 2,      xlab = \"Generations\",      ylab = \"Number of Junctions\",      main = \"Average behaviour Finite Chromosome\",      pch  = 16)  t <- 0:maximum_time predicted <- number_of_junctions(N = n, R = r,                                  H_0 = h_0, C = c,                                  t) lines(predicted ~ t, col = \"blue\") legend(\"bottomright\", c(\"Simulated\", \"Predicted\"),        pch = c(16, NA),        lty = c(NA, 1),        col = c(\"black\", \"blue\"))"},{"path":"https://thijsjanzen.github.io/junctions/articles/junctions_vignette.html","id":"other-equations-available","dir":"Articles","previous_headings":"Junctions vignette","what":"Other equations available","title":"Junctions Vignette","text":"Apart function ‘number_of_junctions’, calculates expected number junctions time t (Equation 11 main text), also provide code calculate age, given number junctions (Equation 14) relative error age estimate (Equation 15). Let’s first calculate number junctions t = 200, population size 100, finite chromosome 1000 elements (initial heterozygosity = 0.5, C = 1). Now, imagine measured J, wanted calculate time (t = 200), information. use function ‘estimate_time’, takes number junctions J, population size N, number equidistant elements R, initial heterozygosity H_0 number crossovers meiosis C arguments: see indeed get correct age (200 generations). obtain relative error estimate, can make use function ‘time_error’: prefer error absolute terms (e.g. generations), can set ‘relative’ flag FALSE obtain: seems like reasonably low error. get insight estimated error, might prove useful calculate maximum accurate time, t_MAT. can calculated using: shows us specific population, specific number markers, junction information can reliably infer onset hybridization 700 generations hybridization event. Nevertheless, keep back minds onset hybridization gets close 700 generations, error already starts becoming increasingly large, reliable upper limit might therefore much lower. can explore plotting number junctions, error estimate joint plot.","code":"num_j <- number_of_junctions(N = 100,                              R = 1000,                              H_0 = 0.5,                              C = 1,                              t = 200) num_j <- tail(num_j, 1) num_j ## [1] 58.32437 time_estim <- estimate_time(J = num_j,                             N = 100,                             R = 1000,                             H_0 = 0.5,                             C = 1) time_estim ## [1] 200 time_error(t = time_estim,            N = 100,            R = 1000,            H_0 = 0.5,            C = 1,            relative = TRUE) ## [1] 0.03390377 time_error(t = time_estim,            N = 100,            R = 1000,            H_0 = 0.5,            C = 1,            relative = FALSE) ## [1] 6.780754 calculate_mat(N = 100,               R = 1000,               H_0 = 0.5,               C = 1) ## [1] 734.9278 maximum_time <- 1000 t <- 0:maximum_time num_j <- number_of_junctions(N = 100,                              R = 1000,                              H_0 = 0.5,                              C = 1,                              t = t) par(mar = c(4, 5, 2, 3)) plot(num_j ~ t,      type = \"l\",      xlab = \"Generations\",      ylab = \"Number of Junctions\",      xlim = c(0, maximum_time)) #vertical line that indicates the upper limit abline(v = calculate_mat(N = 100,                          R = 1000,                          H_0 = 0.5,                          C = 1),        lty = 2)  par(new = TRUE) v <- time_error(t = 0:(maximum_time - 1), #to avoid an error at t = maxT                 N = 100,                 R = 1000,                 H_0 = 0.5,                 C = 1,                 relative = TRUE) ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced ## Warning in log(u^x - 1/K): NaNs produced plot(v,      col = \"red\", type = \"l\",      xlim = c(0, maximum_time),      ylim = c(0, 1),      xaxt = \"n\", yaxt = \"n\",      xlab = \"\", ylab = \"\") axis(4) mtext(\"Relative error\", side = 4, line = 2) legend(\"bottomright\",        c(\"Number of junctions\", \"Relative Error\", \"t_MAX\"),        lty = c(1, 1, 2),        col = c(\"black\", \"red\", \"black\"))"},{"path":"https://thijsjanzen.github.io/junctions/articles/phased_and_unphased_data.html","id":"phased-and-unphased-data","dir":"Articles","previous_headings":"","what":"Phased and unphased data","title":"Phased and unphased data","text":"vignette, explore analyze phased unphased data, using data simulated junctions’ package. go input data needs structured, interpret results.","code":""},{"path":"https://thijsjanzen.github.io/junctions/articles/phased_and_unphased_data.html","id":"simulating-data","dir":"Articles","previous_headings":"","what":"Simulating data","title":"Phased and unphased data","text":"example data, first simulate artificial data. can follows: returns tibble following columns: time, individual, location, anc_chrom_1 anc_chrom_2. contains ancestry chromosomes 10 sampled individuals, 0 indicates allele ancestor 0, 1 indicates allele ancestor 1. Locations given Morgan.","code":"simulated_data <- sim_phased_unphased(pop_size = 1000,                                       freq_ancestor_1 = 0.5,                                       total_runtime = 100,                                       size_in_morgan = 1,                                       time_points = 100,                                       markers = 1000)  simulated_data ## # A tibble: 10,000 × 5 ##     time individual location anc_chrom_1 anc_chrom_2 ##    <dbl>      <dbl>    <dbl>       <dbl>       <dbl> ##  1   100          0 0.000104           0           0 ##  2   100          0 0.00165            0           0 ##  3   100          0 0.00248            0           0 ##  4   100          0 0.00402            0           0 ##  5   100          0 0.00450            0           0 ##  6   100          0 0.00721            0           1 ##  7   100          0 0.00740            0           1 ##  8   100          0 0.00751            0           1 ##  9   100          0 0.00866            0           1 ## 10   100          0 0.0109             0           1 ## # ℹ 9,990 more rows"},{"path":"https://thijsjanzen.github.io/junctions/articles/phased_and_unphased_data.html","id":"inferring-the-time-since-admixture","dir":"Articles","previous_headings":"","what":"Inferring the time since admixture","title":"Phased and unphased data","text":"infer time since admixture, need provide junctions package either (case phased) ancestry data. Secondly, need provide vector location Morgan. vector converted recombination distances markers (similar Ancestry HMM treats markers well). Simulation output already contains information can use infer time since admixture: returns two answers: estimate (“minimum”) -loglikelihood (“objective”) raw data already phased (comes easily simulated data), can also use phased framework. , need provide matrix two columns, column reflects ancestry specific chromosome. size matrix (e.g. number rows) correspond length locations vector, locations Morgan. Using simulated data, obtain: yields similar time estimate.","code":"focal_data <- subset(simulated_data, simulated_data$time == 100) admixture_time <- estimate_time_diploid(ancestry_information =                                           cbind(1,                                                 1,                                                 focal_data$location,                                                 focal_data$anc_chrom_1,                                                 focal_data$anc_chrom_2),                                          pop_size = 1000,                                          freq_ancestor_1 = 0.5,                                          phased = FALSE) admixture_time ## # A tibble: 1 × 3 ##   individual  time loglikelihood ##        <dbl> <dbl>         <dbl> ## 1          1  96.4        -2776. morgan_locations <- focal_data$location phased_data <- cbind(focal_data$anc_chrom_1, focal_data$anc_chrom_2) admixture_time_phased <- estimate_time_diploid(ancestry_information =                                                  cbind(1,                                                        1,                                                        morgan_locations,                                                        phased_data),                                               phased = TRUE,                                               pop_size = 1000,                                               freq_ancestor_1 = 0.5)  admixture_time_phased ## # A tibble: 1 × 3 ##   individual  time loglikelihood ##        <dbl> <dbl>         <dbl> ## 1          1  97.6        -3130."},{"path":"https://thijsjanzen.github.io/junctions/articles/phased_and_unphased_data.html","id":"population-size","dir":"Articles","previous_headings":"","what":"Population size","title":"Phased and unphased data","text":"using simulated data, know beforehand size population. reality, hardly ever case. However, can explore impact population size time estimate, varying systematically:   loglikelihood surface typically flat higher population sizes, population size estimate typically correct. want explore effect population size, can also directly calculate likelihood (without optimization) explore impact.  shows likelihood increases strongly population size, past 1000 individuals, significant difference anymore population sizes. typical result, impact 1/(2N) diminishes strongly increasing N becomes much smaller impact recombination time (see also Janzen et al. 2018).","code":"found <- c() for (N in c(100, 1000, 10000, 100000, 1e6, 1e7)) {   admixture_time_phased <- estimate_time_diploid(ancestry_information =                                                  cbind(1,                                                        1,                                                        morgan_locations,                                                        phased_data),                                               phased = TRUE,                                               pop_size = N,                                               freq_ancestor_1 = 0.5)   found <- rbind(found, c(N, admixture_time_phased$time[[1]],                           admixture_time_phased$loglikelihood[[1]])) } found ##       [,1]    [,2]      [,3] ## [1,] 1e+02 95.3125 -3208.226 ## [2,] 1e+03 97.5625 -3129.773 ## [3,] 1e+04 95.3125 -3140.764 ## [4,] 1e+05 95.3125 -3143.178 ## [5,] 1e+06 95.3125 -3143.453 ## [6,] 1e+07 95.3125 -3143.480 plot(found[, 2] ~ found[, 1], log = \"x\",      xlab = \"Population Size\",      ylab = \"Admixture Time\") plot((-1 * found[, 3]) ~ found[, 1], log = \"x\",      xlab = \"Population Size\",      ylab = \"Log Likelihood\") found <- c() for (N in 10 ^ (seq(1, 6, length.out = 100))) {   ll <- junctions::log_likelihood_diploid(local_anc_matrix =                                             cbind(1,                                                   morgan_locations,                                                   phased_data),                                         phased = TRUE,                                         pop_size = N,                                         freq_ancestor_1 = 0.5,                                         t = 100)   found <- rbind(found, c(N, ll)) } plot(found, xlab = \"Population Size\", ylab = \"Log Likelihood\", log = \"x\")"},{"path":"https://thijsjanzen.github.io/junctions/articles/phased_and_unphased_data.html","id":"simulating-data-with-error","dir":"Articles","previous_headings":"","what":"Simulating data with error","title":"Phased and unphased data","text":"reflect phasing error, can also simulate data imposed phasing error, e.g. fixed probability, assignment chromosomes swapped - instance, true ancestry chromosome 1 0 marker j, 1 chromosome 2, probability m, recording swapped appears ancestry 1 chromosome 1 ancestry 0 chromosome 2. simulate data, can use junctions package: Now, function returns true data, phased data. can use either infer time since admixture (100 generations) see error induced: Thus, find using data phasing error, considerably higher age estimated, due introduction “fake” junctions result incorrect phasing.","code":"simulated_data <- sim_phased_unphased(pop_size = 1000,                                         freq_ancestor_1 = 0.5,                                         total_runtime = 100,                                         size_in_morgan = 1,                                         time_points = 100,                                         markers = 1000,                                         error_rate = 0.01)  simulated_data$true_data ## # A tibble: 10,000 × 5 ##     time individual location anc_chrom_1 anc_chrom_2 ##    <dbl>      <dbl>    <dbl>       <dbl>       <dbl> ##  1   100          0 0.000958           1           1 ##  2   100          0 0.00240            1           1 ##  3   100          0 0.00249            1           1 ##  4   100          0 0.00408            1           1 ##  5   100          0 0.00629            1           0 ##  6   100          0 0.00707            1           0 ##  7   100          0 0.00842            1           0 ##  8   100          0 0.00851            1           0 ##  9   100          0 0.00876            1           0 ## 10   100          0 0.00908            1           0 ## # ℹ 9,990 more rows simulated_data$phased_data ## # A tibble: 10,000 × 5 ##     time individual location anc_chrom_1 anc_chrom_2 ##    <dbl>      <dbl>    <dbl>       <dbl>       <dbl> ##  1   100          0 0.000958           1           1 ##  2   100          0 0.00240            1           1 ##  3   100          0 0.00249            1           1 ##  4   100          0 0.00408            1           1 ##  5   100          0 0.00629            1           0 ##  6   100          0 0.00707            1           0 ##  7   100          0 0.00842            1           0 ##  8   100          0 0.00851            1           0 ##  9   100          0 0.00876            1           0 ## 10   100          0 0.00908            1           0 ## # ℹ 9,990 more rows focal_true_data <- subset(simulated_data$true_data,                           simulated_data$true_data$individual == 0)  true_data <- cbind(focal_true_data$anc_chrom_1,                    focal_true_data$anc_chrom_2)  true_loc  <- focal_true_data$location  admixture_time_true <- estimate_time_diploid(ancestry_information  =                                                cbind(1,                                                      1,                                                      true_loc,                                                      true_data),                                             phased = TRUE,                                             pop_size = 1000,                                             freq_ancestor_1 = 0.5)  focal_phased_data <- subset(simulated_data$phased_data,                             simulated_data$phased_data$individual == 0)  phased_data <- cbind(focal_phased_data$anc_chrom_1,                      focal_phased_data$anc_chrom_2) phased_loc  <- focal_phased_data$location   admixture_time_error <- estimate_time_diploid(ancestry_information =                                                cbind(1,                                                      1,                                                      phased_loc,                                                      phased_data),                                             phased = TRUE,                                             pop_size = 1000,                                             freq_ancestor_1 = 0.5) admixture_time_true ## # A tibble: 1 × 3 ##   individual  time loglikelihood ##        <dbl> <dbl>         <dbl> ## 1          1  88.6         -293. admixture_time_error ## # A tibble: 1 × 3 ##   individual  time loglikelihood ##        <dbl> <dbl>         <dbl> ## 1          1  108.         -345."},{"path":"https://thijsjanzen.github.io/junctions/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thijs Janzen. Author, maintainer.","code":""},{"path":"https://thijsjanzen.github.io/junctions/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Janzen, Thijs, Arne W. Nolte, Arne Traulsen. breakdown genomic ancestry blocks hybrid lineages given finite number recombination sites. Evolution 72.4 (2018): 735-750. https://doi.org/10.1111/evo.13436","code":"@Article{,   title = {The breakdown of genomic ancestry blocks in hybrid lineages given a finite number of recombination sites},   author = {Thijs Janzen and Arne W. Nolte and Arne Traulsen},   journal = {Evolution},   year = {2018},   volume = {72},   number = {4},   pages = {735-750},   doi = {10.1111/evo.13436}, }"},{"path":"https://thijsjanzen.github.io/junctions/index.html","id":"junctions-","dir":"","previous_headings":"","what":"The Breakdown of Genomic Ancestry Blocks in Hybrid Lineages","title":"The Breakdown of Genomic Ancestry Blocks in Hybrid Lineages","text":"Individual based simulations hybridizing populations, accumulation junctions tracked. Furthermore, mathematical equations provided verify simulation outcomes. simulations mathematical equations based Janzen et al. (2018) Janzen Miro Pina (2022).","code":""},{"path":"https://thijsjanzen.github.io/junctions/index.html","id":"references","dir":"","previous_headings":"","what":"references","title":"The Breakdown of Genomic Ancestry Blocks in Hybrid Lineages","text":"Janzen, T. , Nolte, . W. Traulsen, . (2018), breakdown genomic ancestry blocks hybrid lineages given finite number recombination sites. Evolution, 72: 735-750. https://doi.org/10.1111/evo.13436 Lavretsky, P., Janzen, T. McCracken, KG. (2019) Identifying hybrids & genomics hybridization: Mallards & American black ducks Eastern North America. Ecology Evolution 9: 3470-3490. https://doi.org/10.1002/ece3.4981 Janzen, T., & Miró Pina, V. (2022). Estimating time since admixture phased unphased molecular data. Molecular Ecology Resources, 22, 908–926. https://doi.org/10.1111/1755-0998.13519","code":""},{"path":"https://thijsjanzen.github.io/junctions/index.html","id":"updates","dir":"","previous_headings":"","what":"Updates","title":"The Breakdown of Genomic Ancestry Blocks in Hybrid Lineages","text":"Version 2.1.2: Added Github website  Version 2.1.1: Fixed typo one examples  Version 2.1 : updated tbb multithreading code, sped tests, added NEWS file  Version 2.0 : merged many functions similar functionality, added vignette provides overview functionality.  Version 1.9 : added c++ versions unphased phased likelihoods.  Version 1.8 : added multithreading using TBB library.  Version 1.7 : improved recombination function following Hanno Hildenbrandt’s suggestions  Version 1.6 : Improved recombination function run twice fast  Version 1.5.1: Added option track true number junctions  Version 1.5 : Added simulation functions simulate phased unphased data, including phasing error  Version 1.5 : Added support inferring time since admixture based phased unphased data.  Version 1.4 : Added support estimating number junctions, simulating number junctions, backcrossing scheme, using code supplied Lavretsky et al. 2019.  Version 1.3 : Added support estimating time since admixture using unphased data.  Version 1.3 : Added individual based simulations returning phased unphased data.  Version 1.3 : Updated entire package Roxygen.  Version 1.2 : Added support estimating expected number junctions arbitrarily distributed markers.  Version 1.1 : Updated random number generation picking recombination sites. Previous implementation limited 6 digit precision, current precision least double , minimizing probability recombination occur twice location infinite chromosome.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/calc_k.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the limit of the number of junctions — calc_k","title":"Calculate the limit of the number of junctions — calc_k","text":"Calculate average number junctions infinite number generations, provided information initial heterozygosity, population size number generations.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/calc_k.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the limit of the number of junctions — calc_k","text":"","code":"calc_k(N = Inf, R = Inf, H_0 = 0.5, C = 1)"},{"path":"https://thijsjanzen.github.io/junctions/reference/calc_k.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the limit of the number of junctions — calc_k","text":"N population size R number markers H_0 initial heterozygosity (time admixture) C Mean number crossovers per meiosis (e.g. size Morgan chromosome)","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/calc_k.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the limit of the number of junctions — calc_k","text":"number junctions time = infinity","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/calc_k.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the limit of the number of junctions — calc_k","text":"","code":"k <-  calc_k(N = 100, R = 1000, H_0 = 0.5, C = 1)"},{"path":"https://thijsjanzen.github.io/junctions/reference/calculate_MAT.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to calculate the maximum accurate time — calculate_mat","title":"Function to calculate the maximum accurate time — calculate_mat","text":"Function calculates maximum time hybridization number junctions can still reliably used estimate onset hybridization. following equation 15 Janzen et al. 2018.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/calculate_MAT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to calculate the maximum accurate time — calculate_mat","text":"","code":"calculate_mat(N = Inf, R = Inf, H_0 = 0.5, C = 1)"},{"path":"https://thijsjanzen.github.io/junctions/reference/calculate_MAT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to calculate the maximum accurate time — calculate_mat","text":"N Population Size R Number genetic markers H_0 Frequency heterozygosity t = 0 C Mean number crossovers per meiosis (e.g. size Morgan chromosome)","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/calculate_MAT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to calculate the maximum accurate time — calculate_mat","text":"maximum accurate time","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/calculate_MAT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to calculate the maximum accurate time — calculate_mat","text":"","code":"calculate_mat(N = Inf, R = 1000, H_0 = 0.5, C = 1) #> [1] 6211.5"},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the time since the onset of hybridization, using the number of junctions — estimate_time","title":"Estimate the time since the onset of hybridization, using the number of junctions — estimate_time","text":"Estimate time since onset hybridization, following equation 14 Janzen et al. 2018","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the time since the onset of hybridization, using the number of junctions — estimate_time","text":"","code":"estimate_time(J = NA, N = Inf, R = Inf, H_0 = 0.5, C = 1)"},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the time since the onset of hybridization, using the number of junctions — estimate_time","text":"J observed number junctions N Population Size R Number genetic markers H_0 Frequency heterozygosity t = 0 C Mean number crossovers per meiosis (e.g. size Morgan chromosome)","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the time since the onset of hybridization, using the number of junctions — estimate_time","text":"number generations passed since onset hybridization","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the time since the onset of hybridization, using the number of junctions — estimate_time","text":"","code":"J <- number_of_junctions(N = 100, R = 1000, H_0 = 0.5, C = 1, t = 200) estimate_time(J = J, N = 100, R = 1000, H_0 = 0.5, C = 1) #> [1] 200 # should be 200 again"},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_diploid.html","id":null,"dir":"Reference","previous_headings":"","what":"estimates the time since admixture, given diploid ancestry data. — estimate_time_diploid","title":"estimates the time since admixture, given diploid ancestry data. — estimate_time_diploid","text":"Calculates time since admixture, given unphased ancestry data.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_diploid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"estimates the time since admixture, given diploid ancestry data. — estimate_time_diploid","text":"","code":"estimate_time_diploid(   ancestry_information,   analysis_type = \"individuals\",   phased = FALSE,   pop_size = 1000,   freq_ancestor_1 = 0.5,   lower_lim = 2,   upper_lim = 2000,   num_threads = 1,   verbose = FALSE )"},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_diploid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"estimates the time since admixture, given diploid ancestry data. — estimate_time_diploid","text":"ancestry_information matrix five columns: column 1) indicator individual, column 2) indicator chromosome, 3) location marker Morgan, 4) ancestry chromosome 5) ancestry chromosome 2. analysis_type data broken ? multiple options: \"individuals\" - time inferred individual separately, grouping chromosomes together belong individual. \"chromosomes\" - time inferred chromosome separately, grouping chromosomes together belonging separate individuals. \"separate\" - time inferred chromosome individual separately, \"\" - time inferred jointly chromosomes individuals, grouping chromosomes individuals together. phased data phased? pop_size population size freq_ancestor_1 Frequency ancestor 1 t = 0 lower_lim lower limit optimization algorithm. Increase expected admixture time relatively ancient upper_lim upper limit hte optimization algorithm. set large, recent admixture events can overlooked - best set low possible. num_threads num_threads, default threads. 5 threads recommended. verbose display intermediate output? Default = FALSE","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_haploid.html","id":null,"dir":"Reference","previous_headings":"","what":"estimate time using likelihood for a single chromosome — estimate_time_haploid","title":"estimate time using likelihood for a single chromosome — estimate_time_haploid","text":"Estimate time since onset hybridization, haploid genome","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_haploid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"estimate time using likelihood for a single chromosome — estimate_time_haploid","text":"","code":"estimate_time_haploid(   ancestry_matrix,   N = 1000,   freq_ancestor_1 = 0.5,   lower_lim = 2,   upper_lim = 1000,   verbose = FALSE )"},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_haploid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"estimate time using likelihood for a single chromosome — estimate_time_haploid","text":"ancestry_matrix matrix 3 columns, column 1 = chromosome, column 2 = location Morgan, column 3 = ancestry. N Population Size freq_ancestor_1 Frequency ancestor 1 t = 0 lower_lim lower limit optimization algorithm. Increase expected admixture time relatively ancient upper_lim upper limit optimization algorithm. set large, recent admixture events can overlooked - best set low possible. verbose return verbose output","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_haploid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"estimate time using likelihood for a single chromosome — estimate_time_haploid","text":"number generations passed since onset hybridization","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_one_chrom.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the time since the onset of hybridization, using the observed number of junctions, taking into account the distribution of markers on a single chromosome — estimate_time_one_chrom","title":"Estimate the time since the onset of hybridization, using the observed number of junctions, taking into account the distribution of markers on a single chromosome — estimate_time_one_chrom","text":"Estimate time since onset hybridization, following equation 1 Janzen et al. unpublished","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_one_chrom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the time since the onset of hybridization, using the observed number of junctions, taking into account the distribution of markers on a single chromosome — estimate_time_one_chrom","text":"","code":"estimate_time_one_chrom(   J = NA,   N = Inf,   H_0 = 0.5,   marker_distribution = NA,   lower_lim = 2,   upper_lim = 1000 )"},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_one_chrom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the time since the onset of hybridization, using the observed number of junctions, taking into account the distribution of markers on a single chromosome — estimate_time_one_chrom","text":"J observed number junctions N Population Size H_0 Frequency heterozygosity t = 0 marker_distribution vector containing position markers Morgan. lower_lim lower limit optimization algorithm. Increase expected admixture time relatively ancient upper_lim upper limit optimization algorithm. set large, recent admixture events can overlooked - best set low possible.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_one_chrom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the time since the onset of hybridization, using the observed number of junctions, taking into account the distribution of markers on a single chromosome — estimate_time_one_chrom","text":"number generations passed since onset hybridization","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/estimate_time_one_chrom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the time since the onset of hybridization, using the observed number of junctions, taking into account the distribution of markers on a single chromosome — estimate_time_one_chrom","text":"","code":"markers <- seq(from = 0, to = 1, length.out = 100) J <- number_of_junctions_markers(N = 100, H_0 = 0.5, t = 200, marker_distribution = markers) estimate_time_one_chrom(J = J,                         N = 100,                         H_0 = 0.5,                         marker_distribution = markers) #should be 200 again #> [1] 200"},{"path":"https://thijsjanzen.github.io/junctions/reference/junctions-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Extending The Theory of Junctions — junctions-package","title":"Extending The Theory of Junctions — junctions-package","text":"theory junctions extended package including effect finite number recombination sites along chromosome. package provides functions calculate estimated number junctions, depending time since onset hybridization, population size, number recombination sites, initial heterozygosity number crossovers per meiosis.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/junctions-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extending The Theory of Junctions — junctions-package","text":"package provides individual based simulations order simulate accumulation junctions time, chromosomes finite infinite number recombination sites. Furthermore, package provides mathematical tools verify outcomes individual based simulations. Update version 2.1.1 : fixed typo one examples Update version 2.1.0 : updated tbb::task_scheduler_init tbb::global_control Update version 2.0.2 : simplified tests Update version 2.0 : merged many functions similar functionality, added vignette provides overview functionality. Update version 1.9 : added c++ versions unphased phased likelihoods. Update version 1.8 : added multithreading using TBB library. Update version 1.7 : improved recombination function following Hanno Hildenbrandt's suggestions Update version 1.6  : improved recombination function run twice fast Update version 1.5.1: added option track true number junctions Update version 1.5: added support inferring time since admixture based phased unphased data. Also included simulation functions simulate appropriate data (e.g. phased unphased). Update version 1.4: added support estimating number junctions, simulating number junctions, backcrossing scheme, using code supplied Lavretsky et al. 2019. Update version 1.3: added support estimating time since admixture using unphased data.    Update version 1.3: added individual based simulations returning phased unphased data.    Update version 1.3: Updated entire package Roxygen. Update version 1.2: added support estimating expected number junctions arbitrarily distributed markers. Update version 1.1: updated underlying random number generator picking recombination sites. previous generator limited precision, generate duplicate recombination sites. update fixes ","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/junctions-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extending The Theory of Junctions — junctions-package","text":"Maintainer: Thijs Janzen <thijsjanzen@gmail.com>","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/junctions-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extending The Theory of Junctions — junctions-package","text":"Janzen, T. , Nolte, . W. Traulsen, . (2018), breakdown genomic ancestry blocks hybrid lineages given finite number recombination sites. Evolution, 72: 735-750. doi:10.1111/evo.13436 Lavretsky, P, Janzen, T. McCracken, KG.  (2019) Identifying hybrids & genomics hybridization: Mallards & American black ducks Eastern North America. Ecology Evolution 9: 3470-3490. doi:10.1002/ece3.4981","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_diploid.html","id":null,"dir":"Reference","previous_headings":"","what":"calculate the log likelihood of observing diploid ancestry data. — log_likelihood_diploid","title":"calculate the log likelihood of observing diploid ancestry data. — log_likelihood_diploid","text":"Calculates log likelihood observing phased data, given population size, initial heterozygosity time since admixture","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_diploid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"calculate the log likelihood of observing diploid ancestry data. — log_likelihood_diploid","text":"","code":"log_likelihood_diploid(   local_anc_matrix,   pop_size,   freq_ancestor_1 = 0.5,   t,   phased = FALSE,   num_threads = 1 )"},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_diploid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"calculate the log likelihood of observing diploid ancestry data. — log_likelihood_diploid","text":"local_anc_matrix matrix four columns: column 1) chromosome indicator, 2) location marker Morgan respective chromosome 3) ancestry chromosome 4) ancestry chromosome 2. pop_size population size freq_ancestor_1 Frequency ancestor 1 t = 0 t time since admixture phased data phased ? default false. num_threads number threads, default one thread. Set -1 use available threads.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_diploid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"calculate the log likelihood of observing diploid ancestry data. — log_likelihood_diploid","text":"log likelihood","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_haploid.html","id":null,"dir":"Reference","previous_headings":"","what":"log likelihood of the time since admixture for a haploid genome — log_likelihood_haploid","title":"log likelihood of the time since admixture for a haploid genome — log_likelihood_haploid","text":"log likelihood time since admixture set single chromosomes (ex. Yeast).","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_haploid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"log likelihood of the time since admixture for a haploid genome — log_likelihood_haploid","text":"","code":"log_likelihood_haploid(ancestry_matrix, N = 1000, freq_ancestor_1 = 0.5, t = 2)"},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_haploid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"log likelihood of the time since admixture for a haploid genome — log_likelihood_haploid","text":"ancestry_matrix matrix 3 columns, column 1 = chromosome, column 2 = location Morgan, column 3 = ancestry. N Population Size freq_ancestor_1 Frequency ancestor 1 t = 0 t time since admixture","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/log_likelihood_haploid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"log likelihood of the time since admixture for a haploid genome — log_likelihood_haploid","text":"loglikelihood","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the average number of junctions — number_of_junctions","title":"Calculate the average number of junctions — number_of_junctions","text":"Calculate average number junctions single chromosome t generations, provided information initial heterozygosity, population size number generations.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the average number of junctions — number_of_junctions","text":"","code":"number_of_junctions(N = Inf, R = Inf, H_0 = 0.5, C = 1, t = 100)"},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the average number of junctions — number_of_junctions","text":"N Population Size R Number genetic markers H_0 Frequency heterozygosity t = 0 C Mean number crossovers per meiosis (e.g. size Morgan chromosome) t Time since admixture","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the average number of junctions — number_of_junctions","text":"Estimated number junctions time t","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the average number of junctions — number_of_junctions","text":"","code":"jt <-  number_of_junctions(N = 100, R = 1000, H_0 = 0.5, C = 1, t = 1000) jt2 <- number_of_junctions(N = 100, R = 1000, H_0 = 0.5, C = 1, t = 0:1000)"},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_backcross.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the average number of junctions during backcrossing — number_of_junctions_backcross","title":"Calculate the average number of junctions during backcrossing — number_of_junctions_backcross","text":"Calculate expected number junctions t generations, backcrossing mating scheme.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_backcross.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the average number of junctions during backcrossing — number_of_junctions_backcross","text":"","code":"number_of_junctions_backcross(H_0 = 0.5, C = 1, t = 100)"},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_backcross.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the average number of junctions during backcrossing — number_of_junctions_backcross","text":"H_0 Frequency heterozygosity t = 0 C Mean number crossovers per meiosis (e.g. size Morgan chromosome) t Time since admixture","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_backcross.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the average number of junctions during backcrossing — number_of_junctions_backcross","text":"Estimated number junctions time t","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_backcross.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the average number of junctions during backcrossing — number_of_junctions_backcross","text":"","code":"jt <-  number_of_junctions_backcross(H_0 = 0.1, C = 1, t = 5)"},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_di.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the expected number of junctions between two markers separated by a given amount of recombination — number_of_junctions_di","title":"Calculate the expected number of junctions between two markers separated by a given amount of recombination — number_of_junctions_di","text":"Calculate expected number junctions t generations,  provided information initial heterozygosity, population size,  number generations since onset admixture distance  two markers.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_di.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the expected number of junctions between two markers separated by a given amount of recombination — number_of_junctions_di","text":"","code":"number_of_junctions_di(N = Inf, H_0 = 0.5, t = 100, di = 1e-06)"},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_di.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the expected number of junctions between two markers separated by a given amount of recombination — number_of_junctions_di","text":"N Population Size H_0 Frequency heterozygosity t = 0 t Time since admixture di Distance two markers Morgan","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_di.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the expected number of junctions between two markers separated by a given amount of recombination — number_of_junctions_di","text":"Estimated number junctions time t","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_di.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the expected number of junctions between two markers separated by a given amount of recombination — number_of_junctions_di","text":"","code":"number_of_junctions_di(N = 100, H_0 = 0.5, t = 1000, di = 0.01) #> [1] 0.3333332"},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_markers.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the expected total number of junctions in a chromosome, given the distribution of markers — number_of_junctions_markers","title":"Calculate the expected total number of junctions in a chromosome, given the distribution of markers — number_of_junctions_markers","text":"Calculate expected number junctions t generations, provided information initial heterozygosity, population size, number generations since onset admixture distribution markers.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_markers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the expected total number of junctions in a chromosome, given the distribution of markers — number_of_junctions_markers","text":"","code":"number_of_junctions_markers(   N = Inf,   H_0 = 0.5,   t = 100,   marker_distribution = NA )"},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_markers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the expected total number of junctions in a chromosome, given the distribution of markers — number_of_junctions_markers","text":"N Population Size H_0 Frequency heterozygosity t = 0 t Time since admixture marker_distribution vector containing position markers Morgan.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_markers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the expected total number of junctions in a chromosome, given the distribution of markers — number_of_junctions_markers","text":"Estimated number observed junctions time t","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/number_of_junctions_markers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the expected total number of junctions in a chromosome, given the distribution of markers — number_of_junctions_markers","text":"","code":"markers <- seq(from = 0, to = 1, length.out = 1000) jt <-  number_of_junctions_markers(N = 100,                                   H_0 = 0.5,                                   t = 1000,                                   marker_distribution = markers) random_markers <- sort(runif(1000, 0, 1)) jt2 <- number_of_junctions_markers(N = 100,                                   H_0 = 0.5,                                   t = 1000,                                   marker_distribution = random_markers)"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_backcrossing.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to simulate data using a back crossing scheme — sim_backcrossing","title":"Function to simulate data using a back crossing scheme — sim_backcrossing","text":"Individual based simulation accumulation junctions, back crossing scheme","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_backcrossing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to simulate data using a back crossing scheme — sim_backcrossing","text":"","code":"sim_backcrossing(   population_size = 100,   freq_ancestor_1 = 0.5,   total_runtime = 5,   size_in_morgan = 1,   number_of_markers = 100,   seed = 6,   time_points = -1 )"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_backcrossing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to simulate data using a back crossing scheme — sim_backcrossing","text":"population_size Population size freq_ancestor_1 Frequency ancestor 1 t = 0 total_runtime Number generations simulate size_in_morgan Mean number crossovers per meiosis (e.g. size Morgan chromosome) number_of_markers number molecular markers seed Seed pseudo-random number generator time_points vector time points local ancestry recorded returned end simulation. left -1, ancestry recorded every generation (computationally heavy).","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_backcrossing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to simulate data using a back crossing scheme — sim_backcrossing","text":"List five entries: average_junctions: average number junctions time, detected_junctions: average number detected junctions, given markers. markers: vector locations molecular markers, junction_distribution: distribution junctions per time step average_heterozygosity: average heterozygosity.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_backcrossing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to simulate data using a back crossing scheme — sim_backcrossing","text":"","code":"sim_backcrossing(population_size = 100,                        total_runtime = 5,                        size_in_morgan = 1,                        number_of_markers = 100,                        seed = 6,                        time_points = 1:5) #> $average_junctions #> [1] 0.485 0.440 0.310 0.180 #>  #> $detected_junctions #> [1] 0.465 0.415 0.295 0.170 #>  #> $markers #>   [1] 0.01180642 0.01933798 0.03497799 0.04376882 0.04464693 0.06775731 #>   [7] 0.08209470 0.10351912 0.11354000 0.12224747 0.12887618 0.13357049 #>  [13] 0.13790556 0.14434618 0.14638019 0.15897425 0.16708516 0.16776536 #>  [19] 0.17159321 0.19303798 0.19889418 0.20688505 0.20875709 0.22089998 #>  [25] 0.23957689 0.25365198 0.25883235 0.26029875 0.27446782 0.27980986 #>  [31] 0.34747154 0.34951547 0.35204047 0.37812669 0.38477364 0.39630588 #>  [37] 0.42294457 0.42592437 0.43387928 0.44607088 0.44837856 0.44922129 #>  [43] 0.45086201 0.47754811 0.48334898 0.49151114 0.50652364 0.51913075 #>  [49] 0.52846650 0.53509150 0.54148667 0.54480760 0.55031412 0.56009784 #>  [55] 0.56861911 0.57127711 0.58964303 0.59084356 0.59543129 0.63511870 #>  [61] 0.63747898 0.63927276 0.64007345 0.64138804 0.64373512 0.64495380 #>  [67] 0.65056443 0.65096715 0.65745963 0.66013086 0.67010347 0.67782402 #>  [73] 0.68643371 0.68887698 0.70851656 0.73601246 0.73717091 0.73777945 #>  [79] 0.77606555 0.78322536 0.78563072 0.80229424 0.80282633 0.80720381 #>  [85] 0.81155567 0.82451640 0.84499916 0.85470518 0.85704208 0.86058915 #>  [91] 0.86325870 0.87209400 0.88216151 0.91082443 0.91456731 0.91797463 #>  [97] 0.93506913 0.94177503 0.98056468 0.99789406 #>  #> $junction_distribution #> $junction_distribution[[1]] #>   [1] 1 0 2 1 1 4 0 1 3 4 0 0 0 1 1 2 2 2 0 1 1 0 2 1 1 1 0 0 1 0 0 2 2 1 1 2 1 #>  [38] 0 2 1 0 2 0 0 1 0 0 0 1 0 1 0 1 0 1 1 2 0 2 0 3 1 1 1 0 0 1 0 3 1 2 2 0 1 #>  [75] 0 0 2 2 0 3 1 1 2 0 0 0 0 0 4 0 1 0 0 0 2 0 1 0 0 1 #>  #> $junction_distribution[[2]] #>   [1] 0 0 2 3 3 0 0 1 0 3 0 0 0 0 2 0 2 2 2 0 2 1 0 1 1 1 1 0 0 1 2 3 0 2 0 4 0 #>  [38] 0 0 1 1 2 1 0 1 1 2 2 1 2 0 1 0 2 1 2 0 1 0 0 1 2 1 0 0 1 0 0 0 1 1 0 2 0 #>  [75] 0 0 2 1 1 0 2 1 1 0 2 1 2 0 0 0 0 1 0 0 0 0 0 0 0 0 #>  #> $junction_distribution[[3]] #>   [1] 0 0 1 0 2 4 0 3 0 0 0 0 0 1 0 0 2 0 0 2 0 0 0 0 0 0 2 0 0 1 0 1 0 1 0 0 0 #>  [38] 0 0 0 2 0 1 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 1 1 0 2 2 0 0 2 1 0 0 2 3 1 0 #>  [75] 2 1 0 0 0 0 2 0 0 1 2 0 0 2 1 3 0 1 0 0 0 1 2 0 0 0 #>  #> $junction_distribution[[4]] #>   [1] 0 0 0 1 0 0 0 0 1 0 0 1 1 0 0 0 2 0 0 0 0 2 0 2 1 0 1 0 0 2 0 0 0 0 0 0 0 #>  [38] 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 1 0 0 0 2 0 0 0 0 #>  [75] 0 1 2 0 0 0 1 0 0 0 2 0 1 0 0 0 0 2 0 2 2 0 0 0 0 0 #>  #>  #> $average_heterozygosity #> [1] 0.4698 0.2217 0.1111 0.0450 #>"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_fin_chrom.html","id":null,"dir":"Reference","previous_headings":"","what":"Individual Based Simulation of the accumulation of junctions — sim_fin_chrom","title":"Individual Based Simulation of the accumulation of junctions — sim_fin_chrom","text":"Individual based simulation accumulation junctions chromosome regularly distributed markers.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_fin_chrom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Individual Based Simulation of the accumulation of junctions — sim_fin_chrom","text":"","code":"sim_fin_chrom(   pop_size = 100,   freq_ancestor_1 = 0.5,   total_runtime = 100,   morgan = 1,   seed = 42,   R = 100 )"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_fin_chrom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Individual Based Simulation of the accumulation of junctions — sim_fin_chrom","text":"pop_size Population Size freq_ancestor_1 Frequency ancestor 1 t = 0 total_runtime Maximum time simulation stopped morgan Mean number crossovers per meiosis (e.g. size Morgan chromosome) seed Seed pseudo-random number generator R Number regularly distributed markers","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_fin_chrom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Individual Based Simulation of the accumulation of junctions — sim_fin_chrom","text":"avgJunctions vector average number junctions time = [0, total_runtime]","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_fin_chrom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Individual Based Simulation of the accumulation of junctions — sim_fin_chrom","text":"","code":"sim_fin_chrom(pop_size = 100, freq_ancestor_1 = 0.5,                    total_runtime = 10, morgan = 1, seed = 42,                    R = 100) #> $avgJunctions #>  [1] 0.000 0.405 0.925 1.240 1.655 2.140 2.590 3.325 3.915 4.365 4.660 #>"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_inf_chrom.html","id":null,"dir":"Reference","previous_headings":"","what":"Individual Based Simulation of the accumulation of junctions — sim_inf_chrom","title":"Individual Based Simulation of the accumulation of junctions — sim_inf_chrom","text":"Individual based simulation accumulation junctions chromosome infinite number recombination sites.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_inf_chrom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Individual Based Simulation of the accumulation of junctions — sim_inf_chrom","text":"","code":"sim_inf_chrom(   pop_size = 100,   freq_ancestor_1 = 0.5,   total_runtime = 100,   morgan = 1,   markers = -1,   seed = 42 )"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_inf_chrom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Individual Based Simulation of the accumulation of junctions — sim_inf_chrom","text":"pop_size Population Size freq_ancestor_1 Frequency ancestor 1 t = 0 total_runtime Maximum time simulation stopped morgan Mean number crossovers per meiosis (e.g. size Morgan chromosome) markers number genetic markers superimposed chromosome. markers set -1, markers superimposed (faster simulation) seed Seed pseudo-random number generator","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_inf_chrom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Individual Based Simulation of the accumulation of junctions — sim_inf_chrom","text":"avgJunctions vector average number junctions time = [0, total_runtime]","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_inf_chrom.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Individual Based Simulation of the accumulation of junctions — sim_inf_chrom","text":"","code":"v <- sim_inf_chrom(pop_size = 100, freq_ancestor_1 = 0.5,                    total_runtime = 10, morgan = 1, markers = 100,                    seed = 42) plot(v$avgJunctions, type = \"l\", xlab = \"Generations\", ylab = \"Number of Junctions\", main = \"Example Infinite Chromosome\") lines(v$detectedJunctions, col = \"blue\") legend(\"bottomright\", c(\"Real number\",\"Number detected\"),        lty = 1, col = c(\"black\", \"blue\"))"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_phased_unphased.html","id":null,"dir":"Reference","previous_headings":"","what":"Individual Based Simulation of the accumulation of junctions — sim_phased_unphased","title":"Individual Based Simulation of the accumulation of junctions — sim_phased_unphased","text":"Individual based simulation accumulation junctions, returning phased unphased data. Ancestry chromosomes 10 randomly sampled individuals per generations returned.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_phased_unphased.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Individual Based Simulation of the accumulation of junctions — sim_phased_unphased","text":"","code":"sim_phased_unphased(   pop_size = 100,   freq_ancestor_1 = 0.5,   total_runtime = 100,   size_in_morgan = 1,   markers = 100,   time_points = -1,   num_threads = 1,   verbose = FALSE,   record_true_junctions = FALSE,   num_indiv_sampled = 10,   coverage = 1,   error_rate = 0 )"},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_phased_unphased.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Individual Based Simulation of the accumulation of junctions — sim_phased_unphased","text":"pop_size Population Size freq_ancestor_1 Frequency ancestor 1 t = 0 total_runtime Maximum time simulation stopped size_in_morgan Mean number crossovers per meiosis (e.g. size Morgan chromosome) markers single number provided, number used total number markers generated either randomly, using regular distribution (regular distribution chosen number negative). vector provided, vector used. time_points vector time points local ancestry recorded returned end simulation. left -1, ancestry recorded every generation (computationally heavy). num_threads default 1. -1 takes available threads. verbose displays progress bar record_true_junctions keep track true number junctions? num_indiv_sampled number individuals sampled time point genotyped coverage fraction markers can succesfully phased error_rate fraction markers erroneously phased (e.g. swapped)","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_phased_unphased.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Individual Based Simulation of the accumulation of junctions — sim_phased_unphased","text":"tibble five columns: [time, individual, marker location,                             ancestry chromosome 1, ancestry chromosome 2]","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/sim_phased_unphased.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Individual Based Simulation of the accumulation of junctions — sim_phased_unphased","text":"","code":"if (FALSE) { # \\dontrun{ sim_phased_unphased(pop_size = 100, freq_ancestor_1 = 0.5,                     total_runtime = 10, size_in_morgan = 1,                     markers = 10, time_points = c(0, 5, 10),                     num_threads = 1) } # }"},{"path":"https://thijsjanzen.github.io/junctions/reference/time_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the error in the time estimate — time_error","title":"Estimate the error in the time estimate — time_error","text":"Calculate error estimate onset hybridization, following Equations 3 & 4 Supplementary information Janzen et al. 2018.","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/time_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the error in the time estimate — time_error","text":"","code":"time_error(t = NA, N = Inf, R = Inf, H_0 = 0.5, C = 1, relative = TRUE)"},{"path":"https://thijsjanzen.github.io/junctions/reference/time_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the error in the time estimate — time_error","text":"t Inferred time N Population Size R Number genetic markers H_0 Frequency heterozygosity t = 0 C Mean number crossovers per meiosis (e.g. size Morgan chromosome) relative Boolean flag, TRUE: return relative error, FALSE: return error generations","code":""},{"path":"https://thijsjanzen.github.io/junctions/reference/time_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the error in the time estimate — time_error","text":"Expected error time estimate","code":""}]
